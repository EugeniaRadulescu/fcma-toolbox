#!/bin/bash
set -u

# This file is part of the Princeton FCMA Toolbox, (c) 2013 
# written by bdsinger@princeton.edu

#defaults 
USE_QSUB=0
DRY_RUN=0
GEN_TEMPLATE=0
APP=pni_fcma
ME=$(basename $0)

(( $# == 0 )) && printf "%s jobfile.fcma. Type \"$ME template\" to generate a template.fcma file and follow the comments within\n" && exit 1
(( $# > 0 )) && [[ $1 =~ template ]] && GEN_TEMPLATE=1
(( GEN_TEMPLATE == 0 )) && JOBFILE=$1
(( $# > 1 )) && [[ $@ =~ noqsub ]] && USE_QSUB=0
(( $# > 1 )) && [[ $@ =~ dry ]] && DRY_RUN=1

# prefix commands that launch jobs with
# dryecho -- on dryrun just prints command
(( DRY_RUN )) && dryecho="echo" || dryecho=""
# or cat script not run it
(( DRY_RUN )) && drycat="cat" || drycat=""

# ----------------
#      prints list of descriptions for each
#      keyword to template.fcma file
#      and template_blocks.txt 
# ----------------
function generate_template() {
 declare -a key_and_descriptions
 key_and_descriptions=(
        'omp_num_threads:2'                  'Set equal to (cores per node) / (slaves per node)'
        'hostfile:hostfile.txt'              'Each line should have "<hostname>  slots=<slaves_per_node>"'
        'num_processors:3'                   'Number of slaves + 1 (master). Balanced across nodes.'
        "exefile:$APP"                       'Path to the pni_fcma binary, only needed if it is not in PATH'
        "datadir:data/"                      'Every NIfTI dataset (usually == subject) in this dir will be used'
        "matrix_format:.nii.gz"               'File extension for fmri data. Currently only NIfTI compressed (.nii.gz) is supported.'
        "outputfile:top_voxels.txt"          'Your name for the text file that will contain the list of top-scoring voxels (task 0)'
        "task_type:0"                        'Roughly 2 categories: 1) top-voxel selection (0) and 2) prediction using top voxels (4)'
        "blockfile:blockfile.txt"            'Single blocks file to be applied to every fmri data file. See blocks_template.txt for format'
        "blockdir:"                          'Every file in this dir must correspond 1:1 with its dataset-- same name, but .txt not .nii.gz'
        "rows_per_round:100"                 'Empirical value, the rows of FC Matrix (rows*voxels*subjects*blocks) to process per iteration'
        "first_left_out_block_id:-1"         'Here block_id ranges from 0 to subjects*blocks where within-subject blocks are contiguous (skip:-1)'
        "num_items_held_for_test:0"          'Block_ids left out are contiguous, from first_left_out_block_id (flobi) to flobi + this number'
        "is_test_mode:0"                     'Interacts with task_type: 1 (with task 4) when predicting using new data, 0 (with task 0) when selecting top voxels'
        "num_folds_in_feature_selection:8"   'Divides the subjects*blocks samples evenly, does N-1 xvalidation to get each voxel score'
        "first_maskfile:mask1.nii.gz"        'Voxels to score based on autocorrelation or correlation with those in second maskfile'
        "second_maskfile:mask2.nii.gz"       'Besides selection, first & second maskfile can be used with new data in test mode '
        "visualize_blockid:10"               '(used with task_type 8) Which block_id (0..blocks*subjects) correlation matrix to save'
        "visualize_reference:block10.nii.gz" '(used with task_type 8) Name of 4D file, each volume a mask1 voxel, correlated with all mask2 voxels'
)

  outfile="template.fcma"
  echo "# Sample FCMA config file" > $outfile
  echo "" >> $outfile
  (( j = 0 ))
  for ((i=0; i<=numflags; i+=2)); do
    (( j = i + 1 ))
    echo "# ${key_and_descriptions[$j]}" >> $outfile
    echo "${key_and_descriptions[$i]}" >> $outfile
    echo "" >> $outfile
    echo "" >> $outfile
  done
  
  blockout="template_blocks.txt"
  echo "NUM_BLOCKS" > $blockout
  echo "LABEL(0/1)   START_TR  END_TR"  >> $blockout
  echo "   ..." >> $blockout
  echo "(NUM_BLOCKS LINES)" >> $blockout
  echo "" >> $blockout
 
  exit
}

# ----------------
#      list of possible settings
#      and corresponding cmdline flags
# ----------------
declare -a key_and_flags
key_and_flags=(
	omp_num_threads			'OMP_NUM_THREADS='
	num_processors			'-np '
	exefile				' '
	datadir				'-d '
	matrix_format			'-m '
	outputfile			'-t '
	task_type			'-k '
	blockfile			'-b '
	blockdir			'-e '
	rows_per_round			'-s '
	first_left_out_block_id		'-l '
	num_items_held_for_test		'-h '
	is_test_mode			'-c '
	num_folds_in_feature_selection	'-n '
	first_maskfile			'-x '
	second_maskfile			'-y '
	visualize_blockid		'-v '
	visualize_reference		'-r '
)
numflags=${#key_and_flags[@]}

hget() {
	hfile=$1
	grep $2 $1 | cut -d: -f2
}

(( GEN_TEMPLATE > 0 )) && generate_template

#----------------

# first app arg in list above is datadir,
# index 6 (if starting from 0) -- row * 2 cols
app_arg_index=6
app_args=""
# get lines that set a value
jtemp=$(mktemp tmp.XXXXX)
#grep -v '\#' $JOBFILE  | grep '\:[^\w]' > $jtemp
grep -v '\#' $JOBFILE > $jtemp
[[ -n $drycat ]] && $drycat $jtemp
for (( i=$app_arg_index; i<$numflags; i+=2 )); do
	(( j = i + 1 ))
	# substitute the corresponding flag from above
	key="${key_and_flags[$i]}"
	flag="${key_and_flags[$j]}"
	line="$(grep $key: $jtemp)"
	[[ X != X${line} ]] && app_args="$app_args $(echo $line | sed "s/${key}\:/${flag}/")"
done

N=$(hget $jtemp num_processors)
[[ -z $N ]] && echo "num_processors must be specified" && exit 1
M=$(hget $jtemp omp_num_threads)
[[ -z $M ]] && echo "omp_num_threads must be specified" && exit 1
uAPP="$(hget $jtemp exefile)"
[[ -x $uAPP ]] && APP=$uAPP

[[ -n $drycat ]] && $drycat $jtemp

if (( USE_QSUB )); then
	# gridengine config knows about hosts eligible 
	# for $PROJECT, so hostfile not used here
	rm $jtemp
	$dryecho pni_mpirun -P fullcorr $N $M $APP $app_args
else
        hostfile=$(hget $jtemp hostfile)
	rm $jtemp
	# Note that this is not used on rondo but could be
	# if gridengine qsub method has issues
	OMP_NUM_THREADS=$M mpirun -np $N -hostfile $hostfile $APP $app_args
fi

